---
title: "XGR: eXploring Genomic Relations at the gene and SNP level through enrichment, similarity and network analysis"
author: | 
 | [`Hai Fang`](http://www.well.ox.ac.uk/dr-hai-fang), [`Bogdan Knezevic`](http://www.well.ox.ac.uk/bogdan-knezevic), [`Katie L Burnham`](http://www.well.ox.ac.uk/katie-burnham), [`Julian C Knight`](http://www.well.ox.ac.uk/julian-knight)
 |
 | Wellcome Trust Centre for Human Genetics, University of Oxford, UK
date: "`r date()`"
package: "`r packageVersion('XGR')`"
output:
    html_document:
        toc: true
        toc_depth: 3
        number_sections: true
        theme: default
        highlight: tango
        toc_float: true
        fig_caption: true
bibliography: XGR.bib
vignette: >
 %\VignetteIndexEntry{XGR User Manual}
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteEncoding{UTF-8}
 %\VignettePackage{XGR}
 %\VignetteKeywords{Bioinformatics}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment=">")
knitr::opts_chunk$set(dpi=100)
knitr::opts_chunk$set(cache=F)
knitr::opts_chunk$set(echo=T)
knitr::opts_chunk$set(warning=F)
knitr::opts_chunk$set(message=F)
knitr::opts_chunk$set(fig_cap="yes")
```

# Summary

We introduce an R package called *XGR*. This package is designed to make a user-defined gene or SNP list more interpretable by comprehensively utilising ontology and network information to reveal relationships and enhance opportunities for biological discovery. XGR is unique in supporting a broad range of ontologies (including knowledge of biological and molecular functions, pathways, diseases and phenotypes - in both human and mouse) and different types of networks (including functional, physical and pathway interactions). After going through this user manual (particularly the `Applications` section which includes the demo with published data), you will be able to: 1) perform enrichment analysis using either built-in or custom ontologies, 2) calculate semantic similarity between genes (or between SNPs) based on their ontology annotation profiles, and 3) identify a gene subnetwork given your query list of (significant) genes or SNPs. For end-users who are unfamiliar with R, please refer to our user-friendly web app [^1].

[^1]: <http://galahad.well.ox.ac.uk/XGR>

# Installation

We assume [R](http://www.r-project.org), a language and environment for statistical computing and graphics, has been installed. For installation of the XGR package itself (now hosted in *GitHub* [^2]), there are two steps:

* First, install the dependent packages:
```{r eval=F}
source("http://bioconductor.org/biocLite.R")
biocLite(c("devtools","dnet","RCircos","GenomicRanges","ggplot2","ggbio"), siteRepos=c("http://cran.r-project.org"))
```

* Second, install the `XGR` package:
```{r eval=F}
library(devtools)
install_github(c("hfang-bristol/XGR"), dependencies=T)
```

[^2]: <https://github.com/hfang-bristol/XGR>

# Functionality

The functions in the package `XGR` are categorised into five groups according to the tasks they complete. They are summarised below.

## Enrichment functions

Enrichment functions are supposed to do enrichment analysis based on several statistical tests (either Fisher's exact test or hypergeometric/binomial test). The test is to estimate significance of overlaps between, for example, an input group of genes and a group of genes annotated by an ontology term. By default, all annotatable genes are used as the test background but can be specified by the user. If ontology terms are organised as a tree-like structure, this ontology structure can also be taken into account. 

### xEnricherGenes
*[`xEnricherGenes`](http://rawgit.com/hfang-bristol/XGR/master/inst/xEnricherGenes.html)*: conducts gene-based enrichment analysis given a list of genes and the ontology in query. It supports two types of ontologies: 1) structured ontologies including Gene Ontology [@Ashburner2000], Disease Ontology [@Schriml2012], and Phenotype Ontologies in human and mouse [@Kohler2013; @Smith2009], and 2) non-structured ontologies/categories; for example, a collection of pathways, gene expression signatures, transcription factor targets, and gene druggable categories. 

### xEnricherSNPs
*[`xEnricherSNPs`](http://rawgit.com/hfang-bristol/XGR/master/inst/xEnricherSNPs.html)*: conducts SNP-based enrichment analysis using GWAS Catalog traits mapped to Experimental Factor Ontology [@Welter2014]. Inclusion of additional SNPs that are in linkage disequilibrium (LD) with input SNPs are also allowed for enrichment analysis.

### xEnricherYours
*[`xEnricherYours`](http://rawgit.com/hfang-bristol/XGR/master/inst/xEnricherYours.html)*: conducts custom-based enrichment analysis provided with an entity file and an annotation file. 

### xEnrichViewer
*[`xEnrichViewer`](http://rawgit.com/hfang-bristol/XGR/master/inst/xEnrichViewer.html)*: views enrichment results as a data frame that is also useful for the subsequent file saving.

### xEnricher
*[`xEnricher`](http://rawgit.com/hfang-bristol/XGR/master/inst/xEnricher.html)*: acts as a template for enrichment analysis. It is an internal function upon which high-level functions (ie `xEnricherGenes`, `xEnricherSNPs` and `xEnricherYours`) rely.

## Similarity functions

Similarity functions serve to conduct similarity analysis calculating semantic similarity - a type of comparison to assess the degree of relatedness between two entities (eg genes) based on their annotation profiles (by ontology terms). To do so, information content (IC) of a term is first defined to
measure how informative a term is to being used for annotating genes: â€“log10(frequency of genes annotated to this term). Similarity between two terms are then measured based on IC, usually at the most informative common ancester (MICA). Finally, similarity between two entities (eg genes) are derived from pairwise term similarity using best-matching based methods: average, maximum, and complete. 

### xSocialiserGenes
*[`xSocialiserGenes`](http://rawgit.com/hfang-bristol/XGR/master/inst/xSocialiserGenes.html)*: conducts gene-based similarity analysis given a list of genes and the ontology in query. It supports several structured ontologies including Gene Ontology, Disease Ontology, and Phenotype Ontologies (in human and mouse), and returns socialised genes represented as a network with nodes for input genes and edges for pair-wise semantic similarity between them. 

### xSocialiserSNPs
*[`xSocialiserSNPs`](http://rawgit.com/hfang-bristol/XGR/master/inst/xSocialiserSNPs.html)*: 
conducts SNP-based similarity analysis using GWAS Catalog traits mapped to Experimental Factor Ontology. Inclusion of additional SNPs that are in linkage disequilibrium (LD) with input SNPs are also allowed for similarity analysis. It returns socialised SNPs represented as a network with nodes for input SNPs and edges for pair-wise semantic similarity between them.

### xSocialiser
*[`xSocialiser`](http://rawgit.com/hfang-bristol/XGR/master/inst/xSocialiser.html)*: acts as a template for similarity analysis. It is an internal function upon which high-level functions (ie `xSocialiserGenes` and `xSocialiserSNPs`) rely.

## Network functions

Network functions are supposed to identity a gene subnetwork from a gene interaction network with node/gene significant information. The node/gene information can be either directly provided (eg user-defined genes with the significance level; p-values or FDR) or indirectly provided (eg nearby genes of user-defined SNPs with the significance level; GWAS reported p-values). From a gene interaction network with nodes labelled with gene information, the algorithm searching for a maximum-scoring gene subnetwork has been reported in our previous publication [@Fang2014c]), briefed as follows: 1) `score transformation`, that is, given the threshold of tolerable p-value, nodes with p-values below this threshold (nodes of interest) are scored positively, and negative scores for nodes with threshold-above p-values (intolerable), 2) `subnetwork identification`, that is, to find an interconnected gene subnetwork enriched with positive-score nodes, but allowing for a few negative-score nodes as linkers, and 3) `controlling the subnetwork size`, that is, an iterative procedure is provided to finetune tolerable thresholds for identifying the gene subnetwork with a desired number of nodes.

### xSubneterGenes
*[`xSubneterGenes`](http://rawgit.com/hfang-bristol/XGR/master/inst/xSubneterGenes.html)*: takes as input a list of user-defined genes with the significance level (p-values), superposes these genes onto a gene interaction network, and outputs a maximum-scoring gene subnetwork that contains as many most significant (highly scored) genes as possible but also a few less significant (lowly scored) genes as linkers.

### xSubneterSNPs
*[`xSubneterSNPs`](http://rawgit.com/hfang-bristol/XGR/master/inst/xSubneterSNPs.html)*: identifies a gene subnetwork that is likely modulated by input SNPs and/or their Linkage Disequilibrium (LD) SNPs, including two major steps. The first step is to define and score nearby genes that are located within distance window of input and/or LD SNPs. The second step is to use `xSubneterGenes` for identifying a maximum-scoring gene subnetwork.

## Infrastructure functions

Infrastructure functions are essential as they deal with infrastructure including built-in data loading, ontology annotation propagation, calculation of term-term semantic similarity, and graph conversions and visualisations. 

* *[`xRDataLoader`](http://rawgit.com/hfang-bristol/XGR/master/inst/xRDataLoader.html)*: serves as hub for loading built-in data about genes, SNPs, ontologies and annotations. 
* *[`xDAGanno`](http://rawgit.com/hfang-bristol/XGR/master/inst/xDAGanno.html)*: propagates annotations to the ontology root according to the true-path rule. 
* *[`xDAGsim`](http://rawgit.com/hfang-bristol/XGR/master/inst/xDAGsim.html)*: calculates semantic similarity between terms, and returns a network with nodes for terms and edges for pair-wise semantic similarity between them.
* *[`xConverter`](http://rawgit.com/hfang-bristol/XGR/master/inst/xConverter.html)*: converts an object between graph classes. 
* *[`xCircos`](http://rawgit.com/hfang-bristol/XGR/master/inst/xCircos.html)*: visualises the semantic similarity between genes (or SNPs) by the colour of links in a circos plot.
* *[`xVisNet`](http://rawgit.com/hfang-bristol/XGR/master/inst/xVisNet.html)*: visualises the graph in different layouts. 

## Auxiliary functions

Auxiliary functions provide supplementary supports during the package development, such as code debugging and documentation creating. 

* *[`xFunArgs`](http://rawgit.com/hfang-bristol/XGR/master/inst/xFunArgs.html)*: assigns arguments with default values for a given function, useful for code debugging. 
* *[`xRdWrap`](http://rawgit.com/hfang-bristol/XGR/master/inst/xRdWrap.html)*: wraps long texts onto the next line for Rd files.
* *[`xRd2HTML`](http://rawgit.com/hfang-bristol/XGR/master/inst/xRd2HTML.html)*: converts Rd files to HTML files. 

# Applications

An essential step of data analysis is how to make sense of a gene (or SNP) list in a biologically-meaningful way. Genes (and/or SNPs) may be identified from differential expression analysis, eQTL mapping and GWAS. In this section, we showcase the applications using several published datasets. The users are encouraged to adapt the provided codes to analyse their own datasets. 

**First of all, load the package `XGR`:**

```{r, eval=T, include=T}
library(XGR)
# the following packages are needed for visualisation
library(GenomicRanges)
library(RCircos)
```

## Analysing differential genes

The first dataset we use is based on expression data in monocytes [@Fairfax2014]. This dataset *[`JKscience_TS1A`](http://rawgit.com/hfang-bristol/RDataCentre/master/XGR/1.0.0/man/JKscience_TS1A.html)* involves 228 individuals with expression data at four conditions: in the naive state (`Naive`), after 2-hour LPS (`LPS2`), after 24-hour LPS (`LPS24`), and after 24-hour exposure to interferon gamma (`IFN`). Differential expression analysis was performed using the limma package to identify genes that are differentially expressed between two conditions.

**Extract genes that are significantly induced by interferon gamma as compared to the naive state**

```{r, eval=T, cache=T}
# Load differential expression analysis results
res <- xRDataLoader(RData.customised='JKscience_TS1A')
# Create a data frame for genes significantly induced by IFN
flag <- res$logFC_INF24_Naive < 0 & res$fdr_INF24_Naive < 0.01
df <- res[flag, c('Symbol','logFC_INF24_Naive','fdr_INF24_Naive')]
```

The first 5 rows of the data frame `df` are shown below, with the column `logFC_INF24_Naive` telling the log2-transformed fold change: `naive` expression divided by `IFN` expression (thus the induced genes with negative values).

```{r, eval=T, echo=F}
knitr::kable(df[1:5,], digits=200, caption="", row.names=F)
```

### Gene-based enrichment analysis

Enrichment analysis at the gene level can be done by choosing one of ontologies currently supported:

```{r, eval=T, echo=F}
obo <- list()
obo[['DO']] <- c('Disease', 'Disease Ontology', 'DO')
obo[['GOMF']] <- c('Function', 'Gene Ontology Molecular Function', 'GOMF')
obo[['GOBP']] <- c('Function', 'Gene Ontology Biological Process', 'GOBP')
obo[['GOCC']] <- c('Function', 'Gene Ontology Cellular Component', 'GOCC')
obo[['HPPA']] <- c('Phenotype', 'Human Phenotype Phenotypic Abnormality', 'HPPA')
obo[['HPMI']] <- c('Phenotype', 'Human Phenotype Mode of Inheritance', 'HPMI')
obo[['HPCM']] <- c('Phenotype', 'Human Phenotype Clinical Modifier', 'HPCM')
obo[['HPMA']] <- c('Phenotype', 'Human Phenotype Mortality Aging', 'HPMA')
obo[['MP']] <- c('Phenotype', 'Mammalian/Mouse Phenotype', 'MP')
obo[['DGIdb']] <- c('Druggable', 'DGI druggable gene categories', 'DGIdb')
obo[['SF']] <- c('Domain', 'SCOP domain superfamilies', 'SF')
obo[['PS2']] <- c('Evolution', 'phylostratific age information (our ancestors)', 'PS2')
obo[['MsigdbH']] <- c('MsigDB', 'Hallmark gene sets', 'MsigdbH')
obo[['MsigdbC1']] <- c('MsigDB', 'Chromosome and cytogenetic band positional gene sets', 'MsigdbC1')
obo[['MsigdbC2CGP']] <- c('MsigDB', 'Chemical and genetic perturbation gene sets', 'MsigdbC2CGP')
obo[['MsigdbC2CPall']] <- c('MsigDB', 'All pathway gene sets', 'MsigdbC2CPall')
obo[['MsigdbC2CP']] <- c('MsigDB', 'Canonical pathway gene sets', 'MsigdbC2CP')
obo[['MsigdbC2KEGG']] <- c('MsigDB', 'KEGG pathway gene sets', 'MsigdbC2KEGG')
obo[['MsigdbC2REACTOME']] <- c('MsigDB', 'Reactome pathway gene sets', 'MsigdbC2REACTOME')
obo[['MsigdbC2BIOCARTA']] <- c('MsigDB', 'BioCarta pathway gene sets', 'MsigdbC2BIOCARTA')
obo[['MsigdbC3TFT']] <- c('MsigDB', 'Transcription factor target gene sets', 'MsigdbC3TFT')
obo[['MsigdbC3MIR']] <- c('MsigDB', 'microRNA target gene sets', 'MsigdbC3MIR')
obo[['MsigdbC4CGN']] <- c('MsigDB', 'Cancer gene neighborhood gene sets', 'MsigdbC4CGN')
obo[['MsigdbC4CM']] <- c('MsigDB', 'Cancer module gene sets', 'MsigdbC4CM')
obo[['MsigdbC5BP']] <- c('MsigDB', 'GO biological process gene sets', 'MsigdbC5BP')
obo[['MsigdbC5MF']] <- c('MsigDB', 'GO molecular function gene sets', 'MsigdbC5MF')
obo[['MsigdbC5CC']] <- c('MsigDB', 'GO cellular component gene sets', 'MsigdbC5CC')
obo[['MsigdbC6']] <- c('MsigDB', 'Oncogenic signature gene sets', 'MsigdbC6')
obo[['MsigdbC7']] <- c('MsigDB', 'Immunologic signature gene sets', 'MsigdbC7')
df_obo <- do.call(rbind, obo)
colnames(df_obo) <- c('Category', 'Ontology', 'Code')
knitr::kable(df_obo[,c(3,2,1)], caption="", row.names=F)
```

Optionally, the test background can be provided by the user. By default, all annotatable genes will be used. In this case, genes under differential expression analysis will be used as the test background.

```{r, eval=T, cache=T}
background <- res$Symbol
```

> Using a collection of canonical pathways

```{r, eval=T, cache=T, results="hide"}
data <- df$Symbol
eTerm <- xEnricherGenes(data=data, background=background, ontology="MsigdbC2CPall")
# view enrichment results for the top significant terms
xEnrichViewer(eTerm)
# save enrichment results to the file 'Pathway_enrichments.txt'
res_PW <- xEnrichViewer(eTerm, top_num=length(eTerm$adjp), sortBy="adjp", details=F)
output <- data.frame(term=rownames(res_PW), res_PW)
write.table(output, file="Pathway_enrichments.txt", sep="\t", row.names=F)
```

Enrichment results for the top 10 significant pathways are shown below:

```{r, eval=T, echo=F}
knitr::kable(res_PW[1:10,], digits=12, caption="", row.names=F)
```

> Using Disease Ontology (DO)

```{r, eval=T, cache=T, results="hide"}
data <- df$Symbol
eTerm <- xEnricherGenes(data=data, background=background, ontology="DO")
# view enrichment results for the top significant terms
xEnrichViewer(eTerm)
# save enrichment results to the file 'DO_enrichments.txt'
res_DO <- xEnrichViewer(eTerm, top_num=length(eTerm$adjp), sortBy="adjp", details=T)
output <- data.frame(term=rownames(res_DO), res_DO)
write.table(output, file="DO_enrichments.txt", sep="\t", row.names=F)
```
Enrichment results for the top 5 significant terms are shown below:

```{r, eval=T, echo=F, results='asis'}
knitr::kable(res_DO[1:5,1:6], caption="", row.names=F)
```

> Using Mammalian Phenotype (MP)

```{r, eval=T, cache=T, results="hide"}
data <- df$Symbol
eTerm <- xEnricherGenes(data=data, background=background, ontology="MP")
# view enrichment results for the top significant terms
xEnrichViewer(eTerm)
# save enrichment results to the file 'MP_enrichments.txt'
res_MP <- xEnrichViewer(eTerm, top_num=length(eTerm$adjp), sortBy="adjp", details=F)
output <- data.frame(term=rownames(res_MP), res_MP)
write.table(output, file="MP_enrichments.txt", sep="\t", row.names=F)
```
Enrichment results for the top 10 significant terms are shown below:

```{r, eval=T, echo=F}
knitr::kable(res_MP[1:10,], caption="", row.names=F)
```

### Gene-based network analysis

Network analysis at the gene level requires choosing a pre-defined gene networks as a whole network (called `whole-network`). Generally speaking, two sources of whole-network information are supported: the STRING database [@Szklarczyk2015] and the Pathways Commons database [@Cerami2011]. STRING is a meta-integration of undirect interactions from a functional aspect, while Pathways Commons mainly contains both undirect and direct interactions from a physical/pathway aspect. Both have scores to control the confidence of interactions. Therefore, the user can choose the interactions of varying quality in addition to interaction types: 

```{r, eval=T, echo=F}
net <- list()
net[['STRING_highest']] <- c('STRING', 'Functional interactions (with highest confidence scores>=900)', 'STRING_highest')
net[['STRING_high']] <- c('STRING', 'Functional interactions (with high confidence scores>=700)', 'STRING_high')
net[['STRING_medium']] <- c('STRING', 'Functional interactions (with medium confidence scores>=400)', 'STRING_medium')
net[['PCommonsUN_high']] <- c('Pathways Commons', 'Physical/undirect interactions (with references & >=2 sources)', 'PCommonsUN_high')
net[['PCommonsUN_medium']] <- c('Pathways Commons', 'Physical/undirect interactions (with references & >=1 sources)', 'PCommonsUN_medium')
net[['PCommonsDN_high']] <- c('Pathways Commons', 'Pathway/direct interactions (with references & >=2 sources)', 'PCommonsDN_high')
net[['PCommonsDN_medium']] <- c('Pathways Commons', 'Pathway/direct interactions (with references & >=1 sources)', 'PCommonsDN_medium')
df_net <- do.call(rbind, net)
colnames(df_net) <- c('Database', 'Interaction', 'Code')
knitr::kable(df_net[,c(3,2,1)], caption="", row.names=F)
```

For the pathway-merged direct interactions, the user can also choose network sourced individually:

```{r, eval=T, echo=F}
net <- list()
net[['PCommonsDN_Reactome']] <- c('Pathways Commons', 'Pathway/direct interactions (only from Reactome)', 'PCommonsDN_Reactome')
net[['PCommonsDN_KEGG']] <- c('Pathways Commons', 'Pathway/direct interactions (only from KEGG)', 'PCommonsDN_KEGG')
net[['PCommonsDN_HumanCyc']] <- c('Pathways Commons', 'Pathway/direct interactions (only from HumanCyc)', 'PCommonsDN_HumanCyc')
net[['PCommonsDN_PID']] <- c('Pathways Commons', 'Pathway/direct interactions (only from PID)', 'PCommonsDN_PID')
net[['PCommonsDN_PANTHER']] <- c('Pathways Commons', 'Pathway/direct interactions (only from PANTHER)', 'PCommonsDN_PANTHER')
net[['PCommonsDN_ReconX']] <- c('Pathways Commons', 'Pathway/direct interactions (only from ReconX)', 'PCommonsDN_ReconX')
net[['PCommonsDN_PhosphoSite']] <- c('Pathways Commons', 'Pathway/direct interactions (only from PhosphoSite)', 'PCommonsDN_PhosphoSite')
net[['PCommonsDN_CTD']] <- c('Pathways Commons', 'Pathway/direct interactions (only from CTD)', 'PCommonsDN_CTD')
df_net <- do.call(rbind, net)
colnames(df_net) <- c('Database', 'Interaction', 'Code')
knitr::kable(df_net[,c(3,2,1)], caption="", row.names=F)
```

In this subsection, from a pre-defined whole-network we demonstrate how to identify a gene network from an input list of genes with the significant info, in this case, the gene network induced by interferon gamma `INF`.

```{r, eval=T, cache=T}
# find maximum-scoring gene subnetwork with the desired node number=75
data <- df[,c("Symbol","fdr_INF24_Naive")]
subnet <- xSubneterGenes(data=data, network="STRING_high", subnet.size=75)
```

The identified gene network with nodes colored according to FDR is shown below:

```{r, fig.width=8, fig.height=8, fig.cap="", eval=T, cache=T, echo=T}
pattern <- -log10(as.numeric(V(subnet)$significance))
pattern[is.infinite(pattern)] <- max(pattern[!is.infinite(pattern)])
vmax <- ceiling(stats::quantile(pattern, 0.75))
vmin <- floor(min(pattern))
xVisNet(g=subnet, pattern=pattern, glayout=layout_(subnet, with_kk()), vertex.shape="sphere", colormap="yr", zlim=c(vmin,vmax), newpage=F, edge.arrow.size=0.3, vertex.label.color="blue", vertex.label.dist=0.35, vertex.label.font=2)
```

## Analysing eQTL SNPs

The second dataset we use is based on an immune-stimulated eQTL mapping study in monocytes [@Fairfax2014]. In this study, eQTLs were defined as SNPs showing significant association with gene expression at four conditions: in the naive state (`Naive`), after 2-hour LPS (`LPS2`), after 24-hour LPS (`LPS24`), and after exposure to interferon gamma (`IFN`). The eQTL association with gene expression is either in a cis- or trans-acting manner; accordingly they are called `cis-eQTLs` and `trans-eQTLs`. Genes whose expression is modulated by eQTLs are called `eGenes`. The significant cis-eQTLs are stored in *[`JKscience_TS2A`](http://rawgit.com/hfang-bristol/RDataCentre/master/XGR/1.0.0/man/JKscience_TS2A.html)*.

**Extract cis-eQTLs induced after 24-hour exposure to interferon gamma**

```{r, eval=T, cache=T}
# Load cis-eQTL mapping results
cis <- xRDataLoader(RData.customised='JKscience_TS2A')
# Create a data frame for cis-eQTLs significantly induced by IFN
ind <- which(cis$IFN_t > 0 & cis$IFN_fdr < 0.05)
df_cis <- cis[ind, c('variant','Symbol','IFN_t','IFN_fdr')]
```

The first 5 rows of the data frame `df_cis` are shown below:

```{r, eval=T, echo=F}
knitr::kable(df_cis[1:5,], digits=12, caption="", row.names=F)
```

### SNP-based enrichment analysis

> Only for input SNPs reported in GWAS Catalog traits mapped to Experimental Factor Ontology (EFO)

```{r, eval=T, cache=T, results="hide"}
data <- df_cis$variant
eTerm <- xEnricherSNPs(data=data, ontology="EF")
# view enrichment results for the top significant terms
xEnrichViewer(eTerm)
# save enrichment results to the file 'EF_enrichments.txt'
res_EF <- xEnrichViewer(eTerm, top_num=length(eTerm$adjp), sortBy="adjp", details=T)
output <- data.frame(term=rownames(res_EF), res_EF)
write.table(output, file="EF_enrichments.txt", sep="\t", row.names=F)
```

Enrichment results for the top 10 terms are shown below:

```{r, eval=T, echo=F}
knitr::kable(res_EF[1:10, 1:6], caption="", row.names=F)
```

> For input SNPs plus their LD SNPs (based on European populations) reported in GWAS Catalog traits mapped to EFO

```{r, eval=T, cache=T, results="hide"}
data <- df_cis$variant
eTerm <- xEnricherSNPs(data=data, ontology="EF", include.LD="EUR", LD.r2=0.8)
# view enrichment results for the top significant terms
xEnrichViewer(eTerm)
# save enrichment results to the file 'EF_LD_enrichments.txt'
res_EF_LD <- xEnrichViewer(eTerm, top_num=length(eTerm$adjp), sortBy="adjp", details=T)
output <- data.frame(term=rownames(res_EF_LD), res_EF_LD)
write.table(output, file="EF_LD_enrichments.txt", sep="\t", row.names=F)
```

Enrichment results for the top 10 significant terms are shown below:

```{r, eval=T, echo=F}
knitr::kable(res_EF_LD[1:10, 1:6], digits=12, caption="", row.names=F)
```

### SNP-based similarity analysis

> Only for input SNPs

```{r, eval=T, cache=T}
data <- df_cis$variant
ig_SNP <- xSocialiserSNPs(data=data, ontology="EF")
# save similarity results to the file 'EF_similarity.txt'
output <- igraph::get.data.frame(ig_SNP, what="edges")
write.table(output, file="EF_similarity.txt", sep="\t", row.names=F)
```

Circos plot of the most similar edges is shown below:

```{r, fig.width=9, fig.height=9, eval=T, cache=T, echo=T}
xCircos(g=ig_SNP, entity="SNP", verbose=F)
```

> For input SNPs plus their LD SNPs

```{r, eval=T, cache=T}
data <- df_cis$variant
ig_SNP_LD <- xSocialiserSNPs(data=data, ontology="EF", include.LD="EUR", LD.r2=0.8)
# save similarity results to the file 'EF_LD_similarity.txt'
output <- igraph::get.data.frame(ig_SNP_LD, what="edges")
write.table(output, file="EF_LD_similarity.txt", sep="\t", row.names=F)
```

Circos plot of the most similar edges is shown below:

```{r, fig.width=9, fig.height=9, eval=T, cache=T, echo=T}
xCircos(g=ig_SNP_LD, entity="SNP", verbose=F)
```

### SNP-based network analysis

In this section, from a pre-defined whole-network (see above) we demonstrate how to identify a gene network given an input list of SNPs with the significant info, in this case, the gene network likely modulated by INF-induced cis-eQTLs.

```{r, eval=T, cache=T}
# find maximum-scoring gene subnetwork with the desired node number=60
data <- df_cis[,c("variant","IFN_fdr")]
subnet_SNP <- xSubneterSNPs(data=data, network="STRING_high", distance.max=200000, seed.genes=T, subnet.significance=1e-1, subnet.size=60)
```

The identified gene network with nodes colored according to scores is shown below:

```{r, fig.width=8, fig.height=8, eval=T, cache=T, echo=T}
pattern <- -log10(as.numeric(V(subnet_SNP)$significance))
pattern[is.infinite(pattern)] <- max(pattern[!is.infinite(pattern)])
vmax <- ceiling(stats::quantile(pattern, 0.75))
vmin <- floor(min(pattern))
xVisNet(g=subnet_SNP, pattern=pattern, glayout=layout_(subnet_SNP, with_kk()), vertex.shape="sphere", colormap="yr", zlim=c(vmin,vmax), newpage=F, edge.arrow.size=0.3, vertex.label.color="blue", vertex.label.dist=0.35, vertex.label.font=2)
```

## Analysing GWAS SNPs

The third dataset *[`ImmunoBase`](http://rawgit.com/hfang-bristol/RDataCentre/master/XGR/1.0.0/man/ImmunoBase.html)* is GWAS lead SNPs associated with immunologically related human diseases, obtained from [`ImmunoBase`](http://www.immunobase.org). 

```{r, eval=T, cache=T, results="hide"}
ImmunoBase <- xRDataLoader(RData.customised='ImmunoBase')
# get info about diseases
disease_list <- lapply(ImmunoBase, function(x) x$disease)
# get the number of disease associated variants/SNPs
variants_list <- lapply(ImmunoBase, function(x) length(names(x$variants)))
# get the number of genes that are located within 500kb distance window of SNPs
genes_list <- lapply(ImmunoBase, function(x) length(x$genes_variants))
# create a data frame
df_ib <- data.frame(Code=names(ImmunoBase), Disease=unlist(disease_list), num_SNPs=unlist(variants_list), num_nearby_genes=unlist(genes_list), stringsAsFactors=F)
```

A summary of diseases, GWAS lead SNPs and their nearby genes:

```{r, eval=T, echo=F}
knitr::kable(df_ib, caption="", row.names=F)
```

In the following subsections, we focus on two diseases, Crohn's Disease (CRO) and Celiac Disease (CEL), identifying putative gene networks that are likely modulated by their corresponding lead (or LD) SNPs. The applications in the other diseases can be similarly done.

### SNP-modulated gene network in Crohn's Disease

```{r, eval=T, cache=T}
# get SNPs reported in CRO GWAS and their significance info (p-values)
gr <- ImmunoBase$CRO$variant
data <- as.matrix(mcols(gr)[, c('Variant','Pvalue')])

# find maximum-scoring gene subnetwork with the desired node number=30
subnet_CRO <- xSubneterSNPs(data=data, network="STRING_high", distance.max=500000, seed.genes=T, subnet.size=30)
```

The identified gene network with nodes colored according to scores (the higher the more signficant) is shown below:

```{r, fig.width=8, fig.height=8, eval=T, cache=T, echo=T}
pattern <- -log10(as.numeric(V(subnet_CRO)$significance))
pattern[is.infinite(pattern)] <- max(pattern[!is.infinite(pattern)])
vmax <- ceiling(stats::quantile(pattern, 0.75))
vmin <- floor(min(pattern))
xVisNet(g=subnet_CRO, pattern=pattern, glayout=layout_(subnet_CRO, with_kk()), vertex.shape="sphere", colormap="yr", zlim=c(vmin,vmax), newpage=F, edge.arrow.size=0.3, vertex.label.color="blue", vertex.label.dist=0.35, vertex.label.font=2)
```

> Identify pathways enriched with genes in the identified network

```{r, eval=T, cache=T, results="hide"}
data <- V(subnet_CRO)$name
eTerm <- xEnricherGenes(data=data, ontology="MsigdbC2CPall")
# view enrichment results for the top significant terms
xEnrichViewer(eTerm)
# save enrichment results to the file 'CRO_Pathway_enrichments.txt'
res_CRO_PW <- xEnrichViewer(eTerm, top_num=length(eTerm$adjp), sortBy="adjp", details=F)
output <- data.frame(term=rownames(res_CRO_PW), res_CRO_PW)
write.table(output, file="CRO_Pathway_enrichments.txt", sep="\t", row.names=F)
```

Enrichment results for the top 10 significant pathways are shown below:

```{r, eval=T, echo=F}
knitr::kable(res_CRO_PW[1:10,], digits=12, caption="", row.names=F)
```

### SNP-modulated gene network in Celiac Disease

```{r, eval=T, cache=T}
# get SNPs reported in CEL GWAS and their significance info (p-values)
gr <- ImmunoBase$CEL$variant
data <- as.matrix(mcols(gr)[, c('Variant','Pvalue')])

# find maximum-scoring gene subnetwork with the desired node number=30
subnet_CEL <- xSubneterSNPs(data=data, network="STRING_high", distance.max=500000, seed.genes=T, subnet.size=30)
```

The identified gene network with nodes colored according to scores (the higher the more signficant) is shown below:

```{r, fig.width=8, fig.height=8, eval=T, cache=T, echo=T}
pattern <- -log10(as.numeric(V(subnet_CEL)$significance))
pattern[is.infinite(pattern)] <- max(pattern[!is.infinite(pattern)])
vmax <- ceiling(stats::quantile(pattern, 0.75))
vmin <- floor(min(pattern))
xVisNet(g=subnet_CEL, pattern=pattern, glayout=layout_(subnet_CEL, with_kk()), vertex.shape="sphere", colormap="yr", zlim=c(vmin,vmax), newpage=F, edge.arrow.size=0.3, vertex.label.color="blue", vertex.label.dist=0.35, vertex.label.font=2)
```

> Identify pathways enriched with genes in the identified network

```{r, eval=T, cache=T, results="hide"}
data <- V(subnet_CEL)$name
eTerm <- xEnricherGenes(data=data, ontology="MsigdbC2CPall")
# view enrichment results for the top significant terms
xEnrichViewer(eTerm)
# save enrichment results to the file 'CEL_Pathway_enrichments.txt'
res_CEL_PW <- xEnrichViewer(eTerm, top_num=length(eTerm$adjp), sortBy="adjp", details=F)
output <- data.frame(term=rownames(res_CEL_PW), res_CEL_PW)
write.table(output, file="CEL_Pathway_enrichments.txt", sep="\t", row.names=F)
```

Enrichment results for the top 10 significant pathways are shown below:

```{r, eval=T, echo=F}
knitr::kable(res_CEL_PW[1:10,], digits=20, caption="", row.names=F)
```


# Session Info

Here is the output of `sessionInfo()` on the system on which this user manual was built:

```{r sessionInfo, echo=FALSE}
sessionInfo()
```